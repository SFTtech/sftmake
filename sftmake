#!/usr/bin/env python

# [SFT]make by [SFT]technologies
#
# Released under the GPLv3 or later
#
# As always, this programm comes with NO WARRANTY...
# You may request a version of the program that comes with
# the WARRANTY that it will destroy your distribution via service@sft.mx
#
# (c) 2013 Michael Ensslin
# (c) 2013 Jonas Jelten
# (c) 2013 Andre Kupka

import os
#!/usr/bin/env python

class orderedset:
	""" wrapper around OrderedDict because fak u python

	we just need OrderedSet functionality, so we set val = None for all keys. dirty, nah?"""
	def __init__(self):
		from collections import OrderedDict
		self.storage = OrderedDict()

	#append an element
	#returns true if the element was new
	def append(self, x):
		if(x in self.storage):
			self.storage.pop(x)
			self.storage[x] = None
			return False
		else:
			self.storage[x] = None
			return True

	#delete an element
	def delete(self, x):
		self.storage.pop(x)
	
	#remove all elements
	def clear(self):
		self.storage.clear()
	
	#update the ordered set with an other ordered set
	def update(self, x):
		for v in x:
			self.storage.pop(v)
		self.storage.update(x.storage)
	
	def tolist(self):
		return [x for x in self.storage]
	
	def newest(self):
		return next(reversed(self.storage))

	def __iter__(self):
		return self.storage.__iter__()

def findsmroot():
	path = os.path.abspath('.')
	while(not os.path.isfile(path + "/smfile")):
		if(path == "/"):
			raise Exception("No smfile found")
		else:
			path = os.path.abspath(path + '/..')
	return path

smroot = findsmroot()

#functions for path conversions

#convert path to absolute POSIX path
def abspath(path, relto = '^'):
	#if the path is empty, fak u
	if(not path):
		raise Exception('Path must not be empty')

	#if the path starts with '/', it's already absolute
	if(path[0] == '/'):
		result = path

	#if the path starts with '^', we need to replace that with smroot
	elif(path[0] == '^'):
		result = smroot + '/' + path[1:]

	#else, the path is relative... to relto
	else:
		if(relto[0] != '^'):
			raise Exception('relto must start with ^')
		result = abspath(relto) + '/' + path
	
	return os.path.normpath(result)

#convert path to relative POSIX path
def relpath(path, relto = '^'):
	if(not path): #fak u
		raise Exception("Path must not be empty")
	
	elif(path[0] == '/'):
		return os.path.relpath(path, abspath(relto))

	if(path[0] == '^'):
		return os.path.relpath(smroot + '/' + path[1:], abspath(relto))

	#else, path is already relative to relto
	else:
		return os.path.normpath(path)

#convert path to sftmake path
def smpath(path, relto = '^'):
	#if the path is empty, fak u
	if(not path):
		raise Exception("Path must not be empty")

	#if the path starts with '^', it's already an sftmake path
	if(path[0] == '^'):
		return path

	#else, get relative path
	if(path[0] != '/'):
		path = abspath(path, relto)

	#generate path relative to smroot (to just add ^ then)
	path = os.path.relpath(path, smroot)

	if(path == '.'):
		return '^'
	else:
		return '^/' + path
#!/usr/bin/env python

#dict that contains all variables. key = varname, value = var object
variables = {}

#holds metadata for a config:
#the conf's parent configurations
#the conf's directory
#the conf's rank (BASE, DIR, TARGET, SRC, SRCFORTARGET)
CONF_BASE = 0
CONF_DIR = 1
CONF_TARGET = 2
CONF_SRC = 3
CONF_SRCFORTARGET = 4

class config:
	def __init__(self, parents, directory, rank):
		self.parents = parents
		self.directory = directory
		self.rank = rank

#global dict that holds config metadata for all confs
# key: confname
# value: config metadata object
confinfo = {"default": config([], '^', CONF_BASE)}

#TODO #TODO
#   _____        _
#     |     _   | \   _
#     |    / \  |  | / \	<---  TODO
#     |    \_/  |_/  \_/
#
#	!((a==g++);!(b==g++));(c=~a*)
#
#	c[srcsuffix==cpp][toolchain==gnu]=g++
#
#	'!(c==g++)'
#
#	condnot('!(c==g++)')
#	

class cond:
	"""represents one variable condition (abstract base class? factory class? lol?)"""
	def create(condstr):
		""" abstract condition proxy factory singleton bean (not quite) """

		#read constr until operator sign
		#from that operator, decide which class to produce
		#give varname and condstr to the constructor of that class
		#return that class
		pass

	#abstract, must be implemented
	def check(self, conf, depends = orderedset()):
		raise NotImplementedError()

class cond_equals(cond):
	def __init__(self, varname, val):
		self.val = val
		self.varname = varname

	def check(self, conf, depends = orderedset()):
		return (variables[varname].get(conf, depends) == val)

#modes of variable values
VALMODE_APPEND = 0	#append the value to existing list. if already in list, move it to end
VALMODE_SET = 1		#delete existing list, add value to it
VALMODE_REMOVE = 2	#remove the value from existing list

class val:
	"""
	represents one variable value
	a value has:
		a list of conditions, which all need to be met for the value to have the effect described by its mode
		one of the above modes
		a string value
	"""

	def __init__(self, conditions, mode, string):
		self.conditions = conditions
		self.mode = mode
		self.string = string
	
	def check_conds(self, conf, depends = orderedset()):
		"""check all conditions of this value"""
		if (conditions != None):
			for c in conditions:
				if not c.check(conf, depends):
					return False
		return True
	
	def get(self):
		return (mode, string)


VARTYPE_STRING = 0
VARTYPE_PATH = 1
VARTYPE_INT = 2

class var:
	"""
	one configuration variable
	has a list of values for each conf, each of the values has a list of conditions which all need to be true
	"""

	def __init__(self, name, vartype = VARTYPE_STRING, single = False, defaultvals = []):
		self.name = name
		#add yourself to the global variables dict
		variables[name] = self

		#what type is the variable
		self.vartype = vartype

		#is this variable a single value var?
		#if yes, on reading only the most lately written value is returned
		self.single = single

		#given default values for the var
		self.vals = {"default": defaultvals}
	

	def add(self, val, conf):
		"""add a possible value to this variable"""
		#if vartype is string, simply do nothing
		if(self.vartype == VARTYPE_STRING):
			pass

		#if vartype is a path, then convert the given string to a smpath
		elif(self.vartype == VARTYPE_PATH):
			val = smpath(val, confinfo[conf].directory)

		#if vartype is an int, we parse it as such
		elif(self.vartype == VARTYPE_INT):
			try:
				val = int(val)
			except:
				raise Exception("Value must be an integer")

		#if valtype is a list, then val must be one of the list elements
		elif(isinstance(self.vartype, list)):
			if val not in self.vartype:
				raise Exception("Value must be in " + str(self.vartype))
		else:
			raise Exception("Unknown Valuetype")

		#finally, add the value to the value list for the configuration
		if(conf not in self.vals):
			self.vals[conf] = [val]
		else:
			self.vals[conf].append(val)

	def get(self, conf, depends = orderedset()):
		"""returns the variable value for a certain configuration"""
		if(depends.append(self) == False):
			chain = self.name
			for v in depends:
				chain += ' -> ' + v.name
			raise Exception("Circular dependency detected when resolving conditions: " + chain)

		result = orderedset()

		#for each val from each parent config
		for conf in confparenthyperres(conf):
			for val in self.vals.get(conf, []):
				#if condition of the value evaluates true, apply to result
				if(val.check_conds(conf, depends)):
					(mode, string) = val.get()
					if(mode == VALMODE_APPEND):
						result.append(string)
					elif(mode == VALMODE_SET):
						result.clear()
						result.append(string)
					elif(mode == VALMODE_REMOVE):
						result.remove(string)
		
		if(self.single):
			try:
				return result.newest()
			except:
				raise Exception("No value for single-val variable")
		else:
			return result.tolist()

def confparenthyperres(origin):
	"""
	returns list of all configurations that origin depends on, with origin at the end
	for technical reasons, return value is an ordered dict with 'None' as values
	"""
	result = orderedset()
	for parent in confinfo[origin].parents:
		result.update(confparenthyperres(parent))
	result.append(origin)
	return result

#all variables and their default configurations
var('c', VARTYPE_STRING, True, [
	val(cond.create("srcsuffix==cpp"), VALMODE_APPEND, "g++"),
	val(cond.create("srcsuffix==c"  ), VALMODE_APPEND, "gcc")
])

#the used source files
var('srcs', VARTYPE_PATH, False, [])
#etc... basically, type the variable list from documentation section 3
#!/usr/bin/env python

#1.1.0	<assignment>	::= <vars> <vals>
#
#1.1.1	<vars>			::= {<paddedvarname> [<condition>] [<paddedop>] ','} <paddedvarname> [<condition>] <paddedop>
#1.1.2	<vals>			::= <paddedval> {',' <paddedval>}
#
#1.1.3	<paddedvarname> ::= {' ' | \t} <varname> {' ' | \t}
#1.1.4	<paddedop>		::= {' ' | \t} <op> {' ' | \t}
#1.1.5	<paddedval>		::= {' ' | \t} <val> {' ' | \t}
#
#1.1.6	<op>			::= '+=' | '=' | ':=' | '-='
#1.1.7	<varname>		::= (regex) [a-zA-Z_][a-zA-Z0-9_]*
#1.1.8	<val>			::= (for the syntax of a value, see the description. basically, everything except a comma is allowed). leading and trailing spaces and tabs are ignored
#
#1.1.9	<condition>		::= <varname> <conditionop> <val>
#1.1.10	<conditionop>	::= '==' | '=' | '=~' | '!=' | '>=' | '<=' | '>' | '<'
#1.1.11	<condition>		::= '(' <condition> ')'				;parenthesis are optional, but may be required for some semantics (disambiguities)
#1.1.13	<condition>		::= '!' <condition>					;logic not
#1.1.14	<condition>		::= <condition> ';' <condition>		;logic or
#1.1.15	<condition>		::= <condition> ',' <condition>		;logic and

#the assignment parser, which reads complete assignment lines and delegates parts of its work to the cond and val parsers

class lexer_exception(Exception):
	def __init__(self, char, pos, expected):
		Exception.__init__(self, "Unexpected character: " + char + " at position " + str(pos) + ", expected " + expected)
		self.pos = pos

def evaluate_value(valstr):
	return valstr

def parse_condition(cond):
	return cond

#the lexer states
class assignmentlexerstate:
	VARNAMEBEGIN		= 0		#we expect whitespace or [a-zA-Z_] as first char of varname
	VARNAME				= 1		#we expect [a-zA-Z_0-9] as part of the current varname, whitespace, an assignment operator, "[" or "," 
	VARNAMEOVER			= 2		#we read a whitespace and now expect an assignment operator, whitespaces, "[" or ","
	COND				= 3		#we expected arbitrary characters as condition or "]" that is not escaped
	NEXTVAR_OR_OP		= 4		#we expected an assignment operator or a whitespace
	SKIPEQUALSSIGN		= 5		#we have read first part of assignment operator and now expect an equal sign
	NEXTVAR_OR_VAL		= 6		#we now expect a comma for the next varname, a val or a whitespace
	VAL					= 7		#we expect a single quote, a double quote, a whitespace or any other character
	VAL_QUOTED			= 8		#we expect a single quote
	VAL_DBLQUOTED		= 9		#we expect a double quote
	NEXTVAL				= 10	#we expect a whitespace or any other character

class assignment_var:
	def __init__(self, name, cond, op):
		self.name = name
		self.cond = cond
		self.op = op

	def __repr__(self):
		return self.name + "[" + self.cond + "]" + self.op 

def parse_assignment(line):
	#for quick access to the assignment lexer states
	s = assignmentlexerstate()

	#all variables in this assignment
	assignment_vars=[]
	#all values in this assignment
	assignment_vals=[]
	#position of the current character
	pos = 0

	#starting state of our automaton
	state = s.VARNAMEBEGIN
	#name, operator and condition string of the current variable
	curvarname = curvarop = curvarcond = ""
	#value string of the current value
	curval = ""

	#in some states, a \ will escape the following character(s), which may change their meaning
	#to keep the FSM size within reasonable bounds, this is handled by this variable instead of more states
	is_escaped = False

	#read the whole line char by char
	for c in line:
		if state == s.VARNAMEBEGIN:
			if c.isspace(): #a whitespace - wait for first character of variable name
				pass
			elif c.isalpha() or c == '_': #this is the first character of the variable name
				curvarname += c
				state = s.VARNAME
			else:
				raise lexer_exception(c, pos, "first character of variable name [a-zA-Z_]")

		elif state == s.VARNAME:
			if c.isalnum() or c == '_':	#next character of the variable name...
				curvarname += c
			elif c.isspace():	#variable name is over, now expecting condition, operator or the next varname
				state = s.VARNAMEOVER
			elif c == ',':	#variable name is over, and we immediately get the next varname, no cond or op
				assignment_vars.append(assignment_var(curvarname, curvarcond, curvarop))
				state = s.VARNAMEBEGIN
				curvarname = curvarop = curvarcond = ""
			elif c == '[':	#variable name is over, now follows a condition string
				state = s.COND
			elif c == '=':	#'=' assignment operator, now follows the next variable or a value
				curvarop += c
				state = s.NEXTVAR_OR_VAL
			elif c in ':-+': #one of the operators ':=', '+=', '-='. the next char MUST be a '=' sign
				curvarop += c
				state = s.SKIPEQUALSSIGN
			else:
				raise lexer_exception(c, pos, "character of variable name [a-zA-Z_0-9], operator or condition")

		elif state == s.VARNAMEOVER:
			if c.isspace():	#ignore any number of spaces
				pass
			elif c == ',':	#immediately get the next varname, no cond or op
				assignment_vars.append(assignment_var(curvarname, curvarcond, curvarop))
				state = s.VARNAMEBEGIN
				curvarname = curvarop = curvarcond = ""
			elif c == '[':	#now follows a condition string
				state = s.COND
			elif c == '=':	#'=' assignment operator, now follows the next variable or a value
				curvarop += c
				state = s.NEXTVAR_OR_VAL
			elif c in ':+-':
				curvarop += c
				state = s.SKIPEQUALSSIGN
			else:
				raise lexer_exception(c, pos, "operator or condition")

		elif state == s.COND:
			if c == ']' and not is_escaped:	#condition string over
				state = s.NEXTVAR_OR_OP
			else:
				curvarcond += c

		elif state == s.NEXTVAR_OR_OP:
			if c.isspace(): #ignore any number of spaces
				pass
			elif c == ',':	#immediately get the next varname, no op
				assignment_vars.append(assignment_var(curvarname, curvarcond, curvarop))
				state = s.VARNAMEBEGIN
				curvarname = curvarop = curvarcond = ""
			elif c == '=':	#'=' assignment operator, now follows the next variable or a value
				curvarop += c
				state = s.NEXTVAR_OR_VAL
			elif c in ':+-':
				curvarop += c
				state = s.SKIPEQUALSSIGN
			else:
				raise lexer_exception(c, pos, "operator")

		elif state == s.SKIPEQUALSSIGN:
			if c == '=':	#exactly what we wanted
				curvarop += c
				state = s.NEXTVAR_OR_VAL
			else:
				raise lexer_exception(c, pos, "'='")

		elif state == s.NEXTVAR_OR_VAL:
			if c.isspace(): #ignore any number of spaces
				pass
			else: #current var is over, store it away
				#curvarop is not only valid for this var, but also for all its predecessors that do not have one yet
				for var in reversed(assignment_vars):
					if(var.op == ""):
						var.op = curvarop
					else:
						break

				assignment_vars.append(assignment_var(curvarname, curvarcond, curvarop))
				
				if c == ',': #now follows the next var
					state = s.VARNAMEBEGIN
					curvarname = curvarop = curvarcond = ""
				elif c == '"' and not is_escaped:
#					curval += c
					state = s.VAL_DBLQUOTED
				elif c == "'" and not is_escaped:
#					curval += c
					state = s.VAL_QUOTED
				else: #now follows a val
					curval += c
					state = s.VAL

		elif state == s.VAL:
			if c.isspace(): #this value is over
				assignment_vals.append(curval)
				curval = ""
				state = s.NEXTVAL
			elif c == '"' and not is_escaped:
#				curval += c
				state = s.VAL_DBLQUOTED
			elif c == "'" and not is_escaped:
#				curval += c
				state = s.VAL_QUOTED
			else:
				curval += c

		elif state == s.VAL_QUOTED:
			if c == "'" and not is_escaped:
#				curval += c
				state = s.VAL
			else:
				curval += c

		elif state == s.VAL_DBLQUOTED:
			if c == '"' and not is_escaped:
#				curval += c
				state = s.VAL
			else:
				curval += c

		elif state == s.NEXTVAL:
			if c.isspace(): #ignore any number of spaces
				pass
			elif c == '"' and not is_escaped:
#				curval += c
				state = s.VAL_DBLQUOTED
			elif c == "'" and not is_escaped:
#				curval += c
				state = s.VAL_QUOTED
			else:
				curval += c
				state = s.VAL

		else:
			raise Exception("Illegal lexer state")

#		print("Pos " + str(pos) + "[" + c + "]: State " + str(state))

		if c == '\\' and (state == s.VAL or state == s.VAL_QUOTED or state == s.VAL_DBLQUOTED or state == s.COND):
			is_escaped = not is_escaped
		else:
			is_escaped = False
		pos += 1
	
	#the line is fully lexed, check if state is accepting
	if state == s.VARNAMEBEGIN:
		raise Exception("Line over, but expected variable name")
	elif state == s.VARNAME:
		raise Exception("Line over, but expected operator")
	elif state == s.VARNAMEOVER:
		raise Exception("Line over, but expected operator")
	elif state == s.COND:
		raise Exception("Line over, but inside condition string")
	elif state == s.NEXTVAR_OR_OP:
		raise Exception("Line over, but expected operator")
	elif state == s.SKIPEQUALSSIGN:
		raise Exception("Line over, but expected equals sign")
	elif state == s.NEXTVAR_OR_VAL: #accept
		assignment_vars.append(assignment_var(curvarname, curcond, curop))		
	elif state == s.VAL: #accept
		if curval != "":
			assignment_vals.append(curval)
	elif state == s.VAL_QUOTED:
		raise Exception("Line over, but inside quoted string")
	elif state == s.VAL_DBLQUOTED:
		raise Exception("Line over, but inside doublequoted string")
	elif state == s.NEXTVAL:
		pass #accept
	else:
		raise Exception("At end of line: Illegal lexer state")

	#assignment_vals now contains a list of all values (in unparsed/unlexed string form)
	#assignment_vars now contains a list of all variables, whith unparsed/unlexed condition strings
	for var in assignment_vars:
		try:
			var.cond = parse_condition(var.cond)
		except Exception as e:
			raise Exception("When parsing condition string '" + var.cond + "' for variable " + var.name + ": " + str(e))
	
	assignment_vals_evaluated = []
	for val in assignment_vals:
		try:
			assignment_vals_evaluated.append(evaluate_value(val))
		except Exception as e:
			raise Exception("When evaluating value string '" + val + "': " + str(e))
	#done
	return (assignment_vars, assignment_vals_evaluated)
#!/usr/bin/env python

def main():
	print("fak u dolan")

if __name__ == "__main__":
	main()
