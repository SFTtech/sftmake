#!/usr/bin/env python

#the assignment parser, which reads complete assignment lines and delegates parts of its work to the cond and val parsers

def tokenize_line(line):
	tokens = []
	is_escaped = False
	i = 0
	while i < len(line):
		c = line[i]
		if c == '\\':
			i = i + 1
			if i < len(line):
				c = line[i]
				if c in "\\!=<>()[]{}$'\"|&,;:~ ":
					tokens.append(("OTHER", (str(c), i-1)))
				elif c == 'x':
					if i + 2 < len(line):
						val = int(line[i+1:i+3],16)
						tokens.append(("OTHER", (chr(val), i-1)))
						i = i + 2
					else:
						raise Exception("FU4")
				elif c == 'u':
					if i + 4 < len(line):
						val = int(line[i+1:i+5],16)
						tokens.append(("OTHER", (chr(val), i-1)))
						i = i + 4
					else:
						raise Exception("FU3")
				else:
					raise Exception("FU2")
			else:
				raise Exception("FU")
		elif c in "!=<>()[]{}$'\"|&,;:~":
			tokens.append((str(c), (str(c), i)))
		elif c.isspace():
			tokens.append(("WHITESPACE", (str(c), i)))
		elif c.isalpha() or c == '_':
			tokens.append(("ALPHABETIC", (str(c), i)))
		elif c.isdigit():
			tokens.append(("DIGIT", (str(c), i)))
		else:
			tokens.append(("OTHER", (str(c), i)))
		i = i + 1
	return tokens


class LexerException(Exception):
	def __init__(self, char, pos, expected):
		Exception.__init__(self, "Unexpected character: " + char + " at position " + str(pos) + ", expected " + expected)
		self.pos = pos


class ConditionNode:
	def evaluate(self):
		raise NotImplementedError("evaluate not implemented in abstract base class")

class ConditionNotNode(ConditionNode):
	def __init__(self, child):
		self.child = child

	def __repr__(self):
		return "!(" + str(self.child) + ")"

	def evaluate(self):
		return not self.child.evaluate()

class ConditionJunctorNode(ConditionNode):
	def __init__(self, leftchild, rightchild):
		self.leftchild = leftchild
		self.rightchild = rightchild

class ConditionAndNode(ConditionJunctorNode):
	def __init__(self, leftchild, rightchild):
		ConditionJunctorNode.__init__(self, leftchild, rightchild)

	def __repr__(self):
		return "(" + str(self.leftchild) + ") & (" + str(self.rightchild) + ")"
	
	def evaluate(self):
		return self.leftchild.evaluate() and self.rightchild.evaluate()

class ConditionOrNode(ConditionJunctorNode):
	def __init__(self, leftchild, rightchild):
		ConditionJunctorNode.__init__(self, leftchild, rightchild)

	def __repr__(self):
		return "(" + str(self.leftchild) + ") | (" + str(self.rightchild) + ")"
	
	def evaluate(self):
		return self.leftchild.evaluate() or self.rightchild.evaluate()
	
def condition_test_equals(varval, val):
	return (varval == val)

def condition_test_matches(varval, val):
	return True # TODO stub

def condition_test_less(varval, val):
	return True # TODO stub

def condition_test_greater(varval, val):
	return True # TODO stub

class ConditionTestNode(ConditionNode):
	def __init__(self, vartoken, optoken, valtoken):
		self.var = vartoken.content
		self.val = evaluate_valstr(valtoken.content)
		op = optoken.content
		if op == "==" or op == "=":
			self.testfunc = condition_test_equals
			self.op = "=="
			self.invert = False
		elif op == "!=" or op == "<>":
			self.testfunc = condition_test_equals
			self.op = "!="
			self.invert = True
		elif op == "~=" or op == "=~":
			self.testfunc = condition_test_matches
			self.op = "~="
			self.invert = False
		elif op == "!~" or op == "~!":
			self.testfunc = condition_test_matches
			self.op = "!~"
			self.invert = True
		elif op == "<":
			self.testfunc = condition_test_less
			self.op = "<"
			self.invert = False
		elif op == ">":
			self.testfunc = condition_test_greater
			self.op = ">"
			self.invert = False
		elif op == "<=":
			self.testfunc = condition_test_greater
			self.op = "<="
			self.invert = True
		elif op == ">=":
			self.testfunc = condition_test_less
			self.op = ">="
			self.invert = True
		else:
			raise Exception("Unknown Operator: " + op + " at position " + str(optoken.pos));
	
	def __repr__(self):
		return self.var + self.op + str(self.val)

	def evaluate(self):
		varvalue = get_variable_value(self.var) # TODO get correct variable value
		result = testfunc(varvalue, self.val)
		if self.invert:
			return not result
		else:
			return result
