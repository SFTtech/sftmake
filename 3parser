#!/usr/bin/env python

#1.1.0	<assignment>	::= <vars> <vals>
#
#1.1.1	<vars>			::= {<paddedvarname> [<condition>] [<paddedop>] ','} <paddedvarname> [<condition>] <paddedop>
#1.1.2	<vals>			::= <paddedval> {',' <paddedval>}
#
#1.1.3	<paddedvarname> ::= {' ' | \t} <varname> {' ' | \t}
#1.1.4	<paddedop>		::= {' ' | \t} <op> {' ' | \t}
#1.1.5	<paddedval>		::= {' ' | \t} <val> {' ' | \t}
#
#1.1.6	<op>			::= '+=' | '=' | ':=' | '-='
#1.1.7	<varname>		::= (regex) [a-zA-Z_][a-zA-Z0-9_]*
#1.1.8	<val>			::= (for the syntax of a value, see the description. basically, everything except a comma is allowed). leading and trailing spaces and tabs are ignored
#
#1.1.9	<condition>		::= <varname> <conditionop> <val>
#1.1.10	<conditionop>	::= '==' | '=' | '=~' | '!=' | '>=' | '<=' | '>' | '<'
#1.1.11	<condition>		::= '(' <condition> ')'				;parenthesis are optional, but may be required for some semantics (disambiguities)
#1.1.13	<condition>		::= '!' <condition>					;logic not
#1.1.14	<condition>		::= <condition> ';' <condition>		;logic or
#1.1.15	<condition>		::= <condition> ',' <condition>		;logic and

#the assignment parser, which reads complete assignment lines and delegates parts of its work to the cond and val parsers

class lexer_exception(Exception):
	def __init__(self, char, pos, expected):
		Exception.__init__(self, "Unexpected character: " + char + " at position " + str(pos) + ", expected " + expected)
		self.pos = pos

def evaluate_valstr(valstr):
	return valstr

class conditiontokentype:
	LPAREN		= 0		# '('
	RPAREN		= 1		# ')'
	LOGICUNOP	= 2		# '!'										(unary logic operators)
	LOGICBINOP	= 3		# ';' ',' '&' '|'							(infix binary logic operators)
	TESTOP		= 4		# '==' '=' '~=' '=~' '>=' '<=' '>' '<' '!='	(infix variable test operators)
	VAR			= 5		#											(vars)
	VAL			= 6		#											(vals)

class conditiontoken:
	def __init__(self, tokentype, content, pos):
		self.tokentype = tokentype
		self.content = content
		self.pos = pos

	def __repr__(self):
		return "{" + str(self.tokentype) + ";" + self.content + "}" 

class conditionop:
	EQUALS		= 0
	EQUALSNOT	= 1
	MATCHES		= 2
	GREATEROREQ	= 3
	LESSOREQ	= 4
	GREATER		= 5
	LESS		= 6

class conditionasttestnode:
	def __init__(self, vartoken, optoken, valtoken):
		self.varname = vartoken.content
		self.val = evaluate_valstr(valtoken.content)
		opstr = optoken.content
		if opstr == "=" or opstr == "==":
			self.op = conditionop.EQUALS
		elif opstr == "!=":
			self.op = conditionop.EQUALSNOT
		elif opstr == "~=" or opstr == "=~":
			self.op = conditionop.MATCHES
		elif opstr == ">=":
			self.op = conditionop.GREATEROREQ
		elif opstr == "<=":
			self.op = conditionop.LESSOREQ
		elif opstr == ">":
			self.op = conditionop.GREATER
		elif opstr == "<":
			self.op = conditionop.LESS
		else:
			raise Exception("Unexpected operator: " + opstr + " at position " + optoken.pos)

class conditionlexerstate:
	EXPECTVAR				= 0
	VAR						= 1
	EXPECTOP				= 2
	OP						= 3
	EXPECTVAL				= 4
	VAL						= 5
	VALQUOTED				= 6
	VALDBLQUOTED			= 7
	EXPECTJUNCTOR			= 8
	JUNCTOR					= 9

def tokenize_condition(cond):
	(condstr, pos) = cond

	#for quick access to the condition lexer states and token types
	s = conditionlexerstate()
	tt = conditiontokentype()
	
	#all tokens in this condition
	tokens = []

	state = s.EXPECTVAR
	content = ""
	is_escaped = False
	relpos = 0
	tokenpos = 0

	for c in condstr:
		if state == s.EXPECTVAR:
			if c.isspace():
				pass
			elif c == '!':
				tokens.append(conditiontoken(tt.LOGICUNOP, "!", relpos))
			elif c == '(':
				tokens.append(conditiontoken(tt.LPAREN, "(", relpos))
			elif c.isalpha() or c == '_':
				tokenpos = relpos
				content += c
				state = s.VAR
			else:
				raise lexer_exception(c, relpos, "'!', '(' or beginning of variable")

		elif state == s.VAR:
			if c.isspace():
				tokens.append(conditiontoken(tt.VAR, content, tokenpos))
				content = ""
				state = s.EXPECTOP
			elif c.isalnum() or c == '_':
				content += c
			elif c in "!=~<>":
				tokens.append(conditiontoken(tt.VAR, content, tokenpos))
				tokenpos = relpos
				content = str(c)
				state = s.OP
			else:
				raise lexer_exception(c, relpos, "test operator or variable")

		elif state == s.EXPECTOP:
			if c.isspace():
				pass
			elif c in "!=~<>":
				tokenpos = relpos
				content = str(c)
				state = s.OP
			else:
				raise lexer_exception(c, relpos, "test operator")

		elif state == s.OP:
			if c.isspace():
				tokens.append(conditiontoken(tt.TESTOP, content, tokenpos))
				content = ""
				state = s.EXPECTVAL
			elif c == '"':
				tokens.append(conditiontoken(tt.TESTOP, content, tokenpos))
				tokenpos = relpos
				content = str(c)
				state = s.VALDBLQUOTED
			elif c == "'":
				tokens.append(conditiontoken(tt.TESTOP, content, tokenpos))
				tokenpos = relpos
				content = str(c)
				state = s.VALQUOTED
			elif c in "!=~<>":
				content += c
			elif c in ",;&|()":
				raise lexer_exception(c, relpos, "operator or value")
			else:
				tokens.append(conditiontoken(tt.TESTOP, content, tokenpos))
				tokenpos = relpos
				content = str(c)
				state = s.VAL

		elif state == s.EXPECTVAL:
			if c.isspace():
				pass
			elif c == '"':
				tokenpos = relpos
				content = str(c)
				state = s.VALDBLQUOTED
			elif c == "'":
				tokenpos = relpos
				content = str(c)
				state = s.VALQUOTED
			elif c in ",;&|()!=~<>":
				raise lexer_exception(c, relpos, "value")
			else:
				tokenpos = relpos
				content = str(c)
				state = s.VAL

		elif state == s.VAL:
			if c.isspace():
				tokens.append(conditiontoken(tt.VAL, content, tokenpos))
				content = ""
				state = s.EXPECTJUNCTOR
			elif c == ')' and not is_escaped:
				tokens.append(conditiontoken(tt.VAL, content, tokenpos))
				content = ""
				tokens.append(conditiontoken(tt.RPAREN, ")", relpos))
				state = s.EXPECTJUNCTOR
			elif c == '"' and not is_escaped:
				content += c
				state = s.VALDBLQUOTED
			elif c == "'" and not is_escaped:
				content += c
				state = s.VALQUOTED
			elif c in ",;&|" and not is_escaped:
				tokens.append(conditiontoken(tt.VAL, content, tokenpos))
				tokenpos = relpos
				content = str(c)
				state = s.JUNCTOR
			elif c in "(!=~<>" and not is_escaped:
				raise lexer_exception(c, relpos, "value or junctor")
			else:
				content += c

		elif state == s.VALQUOTED:
			if c == "'" and not is_escaped:
				content += c
				state = s.VAL
			else:
				content += c

		elif state == s.VALDBLQUOTED:
			if c == '"' and not is_escaped:
				content += c
				state = s.VAL
			else:
				content += c

		elif state == s.EXPECTJUNCTOR:
			if c.isspace():
				pass
			elif c == ')':
				tokens.append(conditiontoken(tt.RPAREN, ")", relpos))
			elif c in ",;&|":
				tokenpos = relpos
				content = str(c)
				state = s.JUNCTOR
			else:
				raise lexer_exception(c, relpos, "')' or junctor")

		elif state == s.JUNCTOR:
			if c.isspace():
				tokens.append(conditiontoken(tt.LOGICBINOP, content, tokenpos))
				content = ""
				state = s.EXPECTVAR
			elif c == '!':
				tokens.append(conditiontoken(tt.LOGICBINOP, content, tokenpos))
				content = ""
				tokens.append(conditiontoken(tt.LOGICUNOP, "!", relpos))
				state = s.EXPECTVAR
			elif c == '(':
				tokens.append(conditiontoken(tt.LOGICBINOP, content, tokenpos))
				content = ""
				tokens.append(conditiontoken(tt.LPAREN, "(", relpos))
				state = s.EXPECTVAR
			elif c in ",;&|":
				content += c
			elif c.isalpha() or c == '_':
				tokens.append(conditiontoken(tt.LOGICBINOP, content, tokenpos))
				tokenpos = relpos
				content = str(c)
				state = s.VAR
			else:
				raise lexer_exception(c, relpos, "'(', '!', junctor or variable")

		else:
			raise Exception("Illegal lexer state")

		if c == '\\' and (state == s.VAL or state == s.VALQUOTED or state == s.VALDBLQUOTED): # TODO add other valid states
			is_escaped = not is_escaped
		else:
			is_escaped = False
		relpos += 1
	
	if state ==	s.EXPECTVAR:
		raise Exception("Condition over, but expected variable name")
	elif state == s.VAR:
		raise Exception("Condition over, but expected test operator")
	elif state == s.EXPECTOP:
		raise Exception("Condition over, but expected test operator")
	elif state == s.OP:
		raise Exception("Condition over, but expected value")
	elif state == s.EXPECTVAL:
		raise Exception("Condition over, but expected value")
	elif state == s.VAL: #accepting state
		tokens.append(conditiontoken(tt.VAL, content, tokenpos))
	elif state == s.VALQUOTED:
		raise Exception("Condition over, but inside quoted value")
	elif state == s.VALDBLQUOTED:
		raise Exception("Condition over, but inside double quoted value")
	elif state == s.EXPECTJUNCTOR: #accepting state
		pass
	elif state == s.JUNCTOR:
		raise Exception("Condition over, but expected variable name")
	else:
		raise Exception("Illegal lexer state")

	return tokens

def parse_condition(cond):
	tt = conditiontokentype()

	tokens = tokenize_condition(cond)
	return tokens

	#preprocess token list: find <literal> <op> <literal> triplets

#the lexer states
class assignmentlexerstate:
	VARNAMEBEGIN		= 0		#we expect whitespace or [a-zA-Z_] as first char of varname
	VARNAME				= 1		#we expect [a-zA-Z_0-9] as part of the current varname, whitespace, an assignment operator, "[" or "," 
	VARNAMEOVER			= 2		#we read a whitespace and now expect an assignment operator, whitespaces, "[" or ","
	COND				= 3		#we expected arbitrary characters as condition or "]" that is not escaped
	COND_QUOTED			= 4		#we expect a single quote
	COND_DBLQUOTED		= 5		#we expect a double quote
	NEXTVAR_OR_OP		= 6		#we expected an assignment operator or a whitespace
	SKIPEQUALSSIGN		= 7		#we have read first part of assignment operator and now expect an equal sign
	NEXTVAR_OR_VAL		= 8		#we now expect a comma for the next varname, a val or a whitespace
	VAL					= 9		#we expect a single quote, a double quote, a whitespace or any other character
	VAL_QUOTED			= 10	#we expect a single quote
	VAL_DBLQUOTED		= 11	#we expect a double quote
	NEXTVAL				= 12	#we expect a whitespace or any other character

class assignment_var:
	def __init__(self, name, cond, condpos, op):
		self.name = name
		self.cond = (cond, condpos)
		self.op = op

	def __repr__(self):
		return self.name + str(self.cond) + self.op 

def parse_assignment(line):
	#for quick access to the assignment lexer states
	s = assignmentlexerstate()

	#all variables in this assignment
	assignment_vars=[]
	#all values in this assignment
	assignment_vals=[]
	#position of the current character
	pos = 0

	#starting state of our automaton
	state = s.VARNAMEBEGIN
	#name, operator and condition string of the current variable
	curvarname = curvarop = curvarcond = ""
	curvarcondpos = None
	#value string of the current value
	curval = ""

	#in some states, a \ will escape the following character(s), which may change their meaning
	#to keep the FSM size within reasonable bounds, this is handled by this variable instead of more states
	is_escaped = False

	#read the whole line char by char
	for c in line:
		if state == s.VARNAMEBEGIN:
			if c.isspace(): #a whitespace - wait for first character of variable name
				pass
			elif c.isalpha() or c == '_': #this is the first character of the variable name
				curvarname += c
				state = s.VARNAME
			else:
				raise lexer_exception(c, pos, "first character of variable name [a-zA-Z_]")

		elif state == s.VARNAME:
			if c.isalnum() or c == '_':	#next character of the variable name...
				curvarname += c
			elif c.isspace():	#variable name is over, now expecting condition, operator or the next varname
				state = s.VARNAMEOVER
			elif c == ',':	#variable name is over, and we immediately get the next varname, no cond or op
				assignment_vars.append(assignment_var(curvarname, curvarcond, curvarcondpos, curvarop))
				state = s.VARNAMEBEGIN
				curvarname = curvarop = curvarcond = ""
				curvarcondpos = None
			elif c == '[':	#variable name is over, now follows a condition string
				state = s.COND
				curvarcondpos = pos + 1
			elif c == '=':	#'=' assignment operator, now follows the next variable or a value
				curvarop += c
				state = s.NEXTVAR_OR_VAL
			elif c in ':-+': #one of the operators ':=', '+=', '-='. the next char MUST be a '=' sign
				curvarop += c
				state = s.SKIPEQUALSSIGN
			else:
				raise lexer_exception(c, pos, "character of variable name [a-zA-Z_0-9], operator or condition")

		elif state == s.VARNAMEOVER:
			if c.isspace():	#ignore any number of spaces
				pass
			elif c == ',':	#immediately get the next varname, no cond or op
				assignment_vars.append(assignment_var(curvarname, curvarcond, curvarcondpos, curvarop))
				state = s.VARNAMEBEGIN
				curvarname = curvarop = curvarcond = ""
				curvarcondpos = None
			elif c == '[':	#now follows a condition string
				state = s.COND
				curvarcondpos = pos + 1
			elif c == '=':	#'=' assignment operator, now follows the next variable or a value
				curvarop += c
				state = s.NEXTVAR_OR_VAL
			elif c in ':+-':
				curvarop += c
				state = s.SKIPEQUALSSIGN
			else:
				raise lexer_exception(c, pos, "operator or condition")

		elif state == s.COND:
			if c == ']' and not is_escaped:	#condition string over
				state = s.NEXTVAR_OR_OP
			elif c == "'" and not is_escaped: #single quote
				curvarcond += c
				state = s.COND_QUOTED
			elif c == '"' and not is_escaped: #double quote
				curvarcond += c
				state = s.COND_DBLQUOTED
			else:
				curvarcond += c

		elif state == s.COND_QUOTED:
			if c == "'" and not is_escaped: #single quote
				state = s.COND
			curvarcond += c

		elif state == s.COND_DBLQUOTED:
			if c == '"' and not is_escaped: #single quote
				state = s.COND
			curvarcond += c
	
		elif state == s.NEXTVAR_OR_OP:
			if c.isspace(): #ignore any number of spaces
				pass
			elif c == ',':	#immediately get the next varname, no op
				assignment_vars.append(assignment_var(curvarname, curvarcond, curvarcondpos, curvarop))
				state = s.VARNAMEBEGIN
				curvarname = curvarop = curvarcond = ""
			elif c == '=':	#'=' assignment operator, now follows the next variable or a value
				curvarop += c
				state = s.NEXTVAR_OR_VAL
			elif c in ':+-':
				curvarop += c
				state = s.SKIPEQUALSSIGN
			else:
				raise lexer_exception(c, pos, "operator")

		elif state == s.SKIPEQUALSSIGN:
			if c == '=':	#exactly what we wanted
				curvarop += c
				state = s.NEXTVAR_OR_VAL
			else:
				raise lexer_exception(c, pos, "'='")

		elif state == s.NEXTVAR_OR_VAL:
			if c.isspace(): #ignore any number of spaces
				pass
			else: #current var is over, store it away
				#curvarop is not only valid for this var, but also for all its predecessors that do not have one yet
				for var in reversed(assignment_vars):
					if(var.op == ""):
						var.op = curvarop
					else:
						break

				assignment_vars.append(assignment_var(curvarname, curvarcond, curvarcondpos, curvarop))
				
				if c == ',': #now follows the next var
					state = s.VARNAMEBEGIN
					curvarname = curvarop = curvarcond = ""
				elif c == '"' and not is_escaped:
					curval += c
					state = s.VAL_DBLQUOTED
				elif c == "'" and not is_escaped:
					curval += c
					state = s.VAL_QUOTED
				else: #now follows a val
					curval += c
					state = s.VAL

		elif state == s.VAL:
			if c.isspace(): #this value is over
				assignment_vals.append(curval)
				curval = ""
				state = s.NEXTVAL
			elif c == '"' and not is_escaped:
				curval += c
				state = s.VAL_DBLQUOTED
			elif c == "'" and not is_escaped:
				curval += c
				state = s.VAL_QUOTED
			else:
				curval += c

		elif state == s.VAL_QUOTED:
			if c == "'" and not is_escaped:
				curval += c
				state = s.VAL
			else:
				curval += c

		elif state == s.VAL_DBLQUOTED:
			if c == '"' and not is_escaped:
				curval += c
				state = s.VAL
			else:
				curval += c

		elif state == s.NEXTVAL:
			if c.isspace(): #ignore any number of spaces
				pass
			elif c == '"' and not is_escaped:
				curval += c
				state = s.VAL_DBLQUOTED
			elif c == "'" and not is_escaped:
				curval += c
				state = s.VAL_QUOTED
			else:
				curval += c
				state = s.VAL

		else:
			raise Exception("Illegal lexer state")

#		print("Pos " + str(pos) + "[" + c + "]: State " + str(state))

		if c == '\\' and (state == s.VAL or state == s.VAL_QUOTED or state == s.VAL_DBLQUOTED or state == s.COND):
			is_escaped = not is_escaped
		else:
			is_escaped = False
		pos += 1
	
	#the line is fully lexed, check if state is accepting
	if state == s.VARNAMEBEGIN:
		raise Exception("Line over, but expected variable name")
	elif state == s.VARNAME:
		raise Exception("Line over, but expected operator")
	elif state == s.VARNAMEOVER:
		raise Exception("Line over, but expected operator")
	elif state == s.COND:
		raise Exception("Line over, but inside condition string")
	elif state == s.COND_QUOTED:
		raise Exception("Line over, but inside quoted condition string")
	elif state == s.COND_DBLQUOTED:
		raise Exception("Line over, but inside double quoted condition string")
	elif state == s.NEXTVAR_OR_OP:
		raise Exception("Line over, but expected operator")
	elif state == s.SKIPEQUALSSIGN:
		raise Exception("Line over, but expected equals sign")
	elif state == s.NEXTVAR_OR_VAL: #accept
		assignment_vars.append(assignment_var(curvarname, curvarcond, curvarcondpos, curvarop))		
	elif state == s.VAL: #accept
		if curval != "":
			assignment_vals.append(curval)
	elif state == s.VAL_QUOTED:
		raise Exception("Line over, but inside quoted string")
	elif state == s.VAL_DBLQUOTED:
		raise Exception("Line over, but inside doublequoted string")
	elif state == s.NEXTVAL:
		pass #accept
	else:
		raise Exception("At end of line: Illegal lexer state")

	#assignment_vals now contains a list of all values (in unparsed/unlexed string form)
	#assignment_vars now contains a list of all variables, whith unparsed/unlexed condition strings
	for var in assignment_vars:
		(condstr, dummy) = var.cond
		try:
			var.cond = parse_condition(var.cond)
		except Exception as e:
			raise Exception("When parsing condition string '" + condstr + "' for variable " + var.name + ": " + str(e))

	assignment_vals_evaluated = []
	for val in assignment_vals:
		try:
			assignment_vals_evaluated.append(evaluate_valstr(val))
		except Exception as e:
			raise Exception("When evaluating value string '" + val + "': " + str(e))
	#done
	return (assignment_vars, assignment_vals_evaluated)
