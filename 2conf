#!/usr/bin/env python

#dict that contains all variables. key = varname, value = var object
variables = {}

#holds metadata for a config:
#the conf's parent configurations
#the conf's directory
#the conf's rank (BASE, DIR, TARGET, SRC, SRCFORTARGET)
CONF_BASE = 0
CONF_DIR = 1
CONF_TARGET = 2
CONF_SRC = 3
CONF_SRCFORTARGET = 4

class config:
	def __init__(self, parents, directory, rank):
		self.parents = parents
		self.directory = directory
		self.rank = rank

#global dict that holds config metadata for all confs
# key: confname
# value: config metadata object
confinfo = {"default": config([], '^', CONF_BASE)}

#TODO #TODO
#   _____        _
#     |     _   | \   _
#     |    / \  |  | / \	<---  TODO
#     |    \_/  |_/  \_/
#
#	!((a==g++);!(b==g++));(c=~a*)
#
#	c[srcsuffix==cpp][toolchain==gnu]=g++
#
#	'!(c==g++)'
#
#	condnot('!(c==g++)')
#	

class cond:
	"""represents one variable condition (abstract base class? factory class? lol?)"""
	def create(condstr):
		""" abstract condition proxy factory singleton bean (not quite) """

		#read constr until operator sign
		#from that operator, decide which class to produce
		#give varname and condstr to the constructor of that class
		#return that class
		pass

	#abstract, must be implemented
	def check(self, conf, depends = orderedset()):
		raise NotImplementedError()

class cond_equals(cond):
	def __init__(self, varname, val):
		self.val = val
		self.varname = varname

	def check(self, conf, depends = orderedset()):
		return (variables[varname].get(conf, depends) == val)

#modes of variable values
VALMODE_APPEND = 0	#append the value to existing list. if already in list, move it to end
VALMODE_SET = 1		#delete existing list, add value to it
VALMODE_REMOVE = 2	#remove the value from existing list

class val:
	"""
	represents one variable value
	a value has:
		a list of conditions, which all need to be met for the value to have the effect described by its mode
		one of the above modes
		a string value
	"""

	def __init__(self, conditions, mode, string):
		self.conditions = conditions
		self.mode = mode
		self.string = string
	
	def check_conds(self, conf, depends = orderedset()):
		"""check all conditions of this value"""
		if (conditions != None):
			for c in conditions:
				if not c.check(conf, depends):
					return False
		return True
	
	def get(self):
		return (mode, string)


VARTYPE_STRING = 0
VARTYPE_PATH = 1
VARTYPE_INT = 2

class var:
	"""
	one configuration variable
	has a list of values for each conf, each of the values has a list of conditions which all need to be true
	"""

	def __init__(self, name, vartype = VARTYPE_STRING, single = False, defaultvals = []):
		self.name = name
		#add yourself to the global variables dict
		variables[name] = self

		#what type is the variable
		self.vartype = vartype

		#is this variable a single value var?
		#if yes, on reading only the most lately written value is returned
		self.single = single

		#given default values for the var
		self.vals = {"default": defaultvals}
	

	def add(self, val, conf):
		"""add a possible value to this variable"""
		#if vartype is string, simply do nothing
		if(self.vartype == VARTYPE_STRING):
			pass

		#if vartype is a path, then convert the given string to a smpath
		elif(self.vartype == VARTYPE_PATH):
			val = smpath(val, confinfo[conf].directory)

		#if vartype is an int, we parse it as such
		elif(self.vartype == VARTYPE_INT):
			try:
				val = int(val)
			except:
				raise Exception("Value must be an integer")

		#if valtype is a list, then val must be one of the list elements
		elif(isinstance(self.vartype, list)):
			if val not in self.vartype:
				raise Exception("Value must be in " + str(self.vartype))
		else:
			raise Exception("Unknown Valuetype")

		#finally, add the value to the value list for the configuration
		if(conf not in self.vals):
			self.vals[conf] = [val]
		else:
			self.vals[conf].append(val)

	def get(self, conf, depends = orderedset()):
		"""returns the variable value for a certain configuration"""
		if(depends.append(self) == False):
			chain = self.name
			for v in depends:
				chain += ' -> ' + v.name
			raise Exception("Circular dependency detected when resolving conditions: " + chain)

		result = orderedset()

		#for each val from each parent config
		for conf in confparenthyperres(conf):
			for val in self.vals.get(conf, []):
				#if condition of the value evaluates true, apply to result
				if(val.check_conds(conf, depends)):
					(mode, string) = val.get()
					if(mode == VALMODE_APPEND):
						result.append(string)
					elif(mode == VALMODE_SET):
						result.clear()
						result.append(string)
					elif(mode == VALMODE_REMOVE):
						result.remove(string)
		
		if(self.single):
			try:
				return result.newest()
			except:
				raise Exception("No value for single-val variable")
		else:
			return result.tolist()

def confparenthyperres(origin):
	"""
	returns list of all configurations that origin depends on, with origin at the end
	for technical reasons, return value is an ordered dict with 'None' as values
	"""
	result = orderedset()
	for parent in confinfo[origin].parents:
		result.update(confparenthyperres(parent))
	result.append(origin)
	return result

#all variables and their default configurations
var('c', VARTYPE_STRING, True, [
	val(cond.create("srcsuffix==cpp"), VALMODE_APPEND, "g++"),
	val(cond.create("srcsuffix==c"  ), VALMODE_APPEND, "gcc")
])

#the used source files
var('srcs', VARTYPE_PATH, False, [])
#etc... basically, type the variable list from documentation section 3
